<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>钟馗游戏</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: url('https://raw.githubusercontent.com/annashen0805-art/zhongkui/main/bodybackground.jpg') no-repeat center center fixed;
            background-size: cover;
            overflow: hidden;
            z-index: 0;
        }
        #start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-family: Arial, sans-serif;
            font-size: 32px;
            color: #333;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 10;
        }
        #start-button {
            padding: 15px 30px;
            font-size: 24px;
            border: 1px solid #333;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            background-color: #fff;
        }
        #start-button:hover {
            background-color: #ddd;
        }
        #start-button:active {
            background-color: #bbb;
        }
        #game-area {
            position: relative;
            width: 80%;
            max-width: 800px;
            height: 400px;
            max-height: 400px;
            background: url('https://i.ibb.co/PZbrMCsh/IMG-5097.png') no-repeat center center;
            background-size: cover;
            border: 2px solid #333;
            overflow: hidden;
            z-index: 5;
            display: none;
        }
        #character {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%) scaleX(1) translateZ(0);
            width: 180px;
            max-width: 180px;
            height: 120px;
            max-height: 120px;
            background-image: url('https://raw.githubusercontent.com/annashen0805-art/zhongkui/main/characters.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-color: transparent;
            transition: transform 0.3s ease, left 0.2s ease;
            z-index: 6;
            will-change: transform, left;
        }
        .coin {
            position: absolute;
            width: 70px;
            max-width: 70px;
            height: 70px;
            max-height: 70px;
            background-image: url('https://raw.githubusercontent.com/annashen0805-art/zhongkui/main/coin.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-color: #ffd700;
            border-radius: 50%;
            animation: fall var(--fall-duration, 6s) linear 1, spin2d 2s linear infinite;
            z-index: 6;
            will-change: transform, top;
        }
        .explosion {
            position: absolute;
            width: 80px;
            max-width: 80px;
            height: 80px;
            max-height: 80px;
            background: radial-gradient(circle, 
                rgba(255, 255, 0, 0.9) 0%, 
                rgba(255, 165, 0, 0.7) 30%, 
                rgba(255, 69, 0, 0.5) 50%, 
                rgba(255, 255, 255, 0.3) 70%, 
                rgba(0, 0, 0, 0) 100%
            );
            border-radius: 50%;
            animation: explode 0.6s ease-out forwards;
            pointer-events: none;
            z-index: 7;
            will-change: width, height, opacity;
        }
        @keyframes fall {
            0% { top: -70px; }
            100% { top: 470px; }
        }
        @keyframes spin2d {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes explode {
            0% { width: 80px; height: 80px; opacity: 1; }
            20% { width: 160px; height: 160px; opacity: 0.9; }
            40% { width: 320px; height: 320px; opacity: 0.7; }
            60% { width: 480px; height: 480px; opacity: 0.5; }
            100% { width: 600px; height: 600px; opacity: 0; }
        }
        @keyframes glow {
            0% { box-shadow: 0 0 10px yellow; }
            100% { box-shadow: 0 0 0 transparent; }
        }
        .glow {
            animation: glow 0.3s ease-out;
        }
        #score, #life, #level {
            position: absolute;
            font-family: Arial, sans-serif;
            font-size: 24px;
            color: #333;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 8;
        }
        #score { top: 10px; left: 10px; }
        #life { top: 10px; right: 10px; }
        #level { top: 60px; left: 10px; }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            font-size: 32px;
            color: red;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            display: none;
            text-align: center;
            cursor: pointer;
            z-index: 10;
            max-width: 90%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            line-height: 1.2;
        }
        #controls, #restart-container {
            position: relative;
            margin-top: 10px;
            display: flex;
            gap: 15px;
            justify-content: center;
            display: none;
            z-index: 8;
        }
        #left-button, #jump-button, #right-button, #restart-button {
            padding: 15px 30px;
            font-size: 18px;
            border: 1px solid #333;
            border-radius: 5px;
            cursor: pointer;
            touch-action: manipulation;
            background-color: rgba(255, 255, 255, 0.9);
        }
        #left-button:hover, #jump-button:hover, #right-button:hover, #restart-button:hover {
            background-color: #ddd;
        }
        #left-button:active, #jump-button:active, #right-button:active, #restart-button:active {
            background-color: #bbb;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <div>欢迎体验钟馗游戏！</div>
        <button id="start-button" aria-label="开始游戏">开始游戏</button>
    </div>
    <div id="game-area">
        <div id="character" aria-label="可移动的游戏角色"></div>
        <div id="score">得分: 0 | 最高分: 0</div>
        <div id="life">生命: 5</div>
        <div id="level">等级: 1</div>
        <div id="game-over" tabindex="0" role="alert">
            <div>游戏结束！</div>
            <div>等级: 1</div>
            <div>得分: 0</div>
            <div>最高分: 0</div>
            <div>生命: 5</div>
            <div>点击或按 Enter 重新开始</div>
        </div>
    </div>
    <div id="controls">
        <button id="left-button" aria-label="向左移动角色">左</button>
        <button id="jump-button" aria-label="使角色跳跃">跳跃</button>
        <button id="right-button" aria-label="向右移动角色">右</button>
    </div>
    <div id="restart-container">
        <button id="restart-button" aria-label="重新开始游戏">重新开始</button>
    </div>
    <audio id="bg-music" loop preload="auto">
        <source src="https://raw.githubusercontent.com/annashen0805-art/zhongkui/main/zhongkui.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <script>
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameArea = document.getElementById('game-area');
        const controls = document.getElementById('controls');
        const restartContainer = document.getElementById('restart-container');
        const character = document.getElementById('character');
        const scoreDisplay = document.getElementById('score');
        const lifeDisplay = document.getElementById('life');
        const levelDisplay = document.getElementById('level');
        const gameOverDisplay = document.getElementById('game-over');
        const leftButton = document.getElementById('left-button');
        const jumpButton = document.getElementById('jump-button');
        const rightButton = document.getElementById('right-button');
        const restartButton = document.getElementById('restart-button');
        const bgMusic = document.getElementById('bg-music');

        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        const gameConfig = {
            medium: {
                maxLife: 5,
                initialSpawnInterval: 2000,
                spawnIntervalDecrease: 25,
                minSpawnInterval: 500,
                moveSpeed: 5,
                jumpHeight: '-150px',
                initialFallDuration: 6,
                fallDurationDecrease: 0.3,
                minFallDuration: 2,
                maxCoins: (level) => isMobile ? Math.min(8, Math.floor(level / 2) + 3) : Math.min(15, Math.floor(level / 2) + 5),
            },
        };

        let currentConfig = gameConfig.medium;
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        let life = currentConfig.maxLife;
        let level = 1;
        let isJumping = false;
        let coinCount = 0;
        let spawnInterval = currentConfig.initialSpawnInterval;
        let isGameOver = false;
        let lastSpawnTime = 0;
        let characterX = 50;
        let isFacingRight = true;
        let moveDirection = 0;
        let lastCollisionCheck = 0;
        let lastFrameTime = 0;
        const collisionCheckInterval = 200;
        const coins = [];
        const explosionPool = [];
        const maxExplosionPoolSize = 10;
        let gameAreaRect = null;

        // Fallback base64 images (replace with actual base64 strings for your assets)
        const fallbackCharacterImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGURgAAAABJRU5ErkJggg==';
        const fallbackCoinImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHogJ/PdX9BAAAAABJRU5ErkJggg==';

        // Preload images and audio
        const preloadImages = [
            'https://i.ibb.co/GKJ0mzX/IMG-5096.jpg',
            'https://i.ibb.co/PZbrMCsh/IMG-5097.png',
            'https://i.ibb.co/2mpzr9Y/IMG-5090.png',
            'https://i.ibb.co/LhvzWrfc/IMG-5089.webp',
        ];
        preloadImages.forEach(src => {
            const img = new Image();
            img.src = src;
        });
        bgMusic.load();
        bgMusic.volume = 0.3;

        function updateGameAreaRect() {
            gameAreaRect = gameArea.getBoundingClientRect();
        }
        window.addEventListener('resize', updateGameAreaRect);
        updateGameAreaRect();

        function startGame() {
            startScreen.style.display = 'none';
            gameArea.style.display = 'block';
            controls.style.display = 'flex';
            restartContainer.style.display = 'flex';
            bgMusic.play().catch(error => {
                console.error('背景音乐播放失败:', error);
            });
            restartGame();
        }

        startButton.addEventListener('click', startGame);

        function jump() {
            if (!isJumping && !isGameOver) {
                isJumping = true;
                character.style.transform = `translateX(-50%) translateY(${currentConfig.jumpHeight}) scaleX(${isFacingRight ? 1 : -1}) translateZ(0)`;
                setTimeout(() => {
                    character.style.transform = `translateX(-50%) translateY(0) scaleX(${isFacingRight ? 1 : -1}) translateZ(0)`;
                    isJumping = false;
                }, 300);
            }
        }

        function updateCharacterPosition() {
            if (!isGameOver && moveDirection !== 0) {
                characterX = Math.max(9, Math.min(91, characterX + moveDirection * currentConfig.moveSpeed));
                character.style.left = `${characterX}%`;
                isFacingRight = moveDirection > 0;
                character.style.transform = `translateX(-50%) scaleX(${isFacingRight ? 1 : -1})${isJumping ? ` translateY(${currentConfig.jumpHeight})` : ''} translateZ(0)`;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                jump();
            } else if (e.code === 'ArrowLeft') {
                e.preventDefault();
                moveDirection = -1;
            } else if (e.code === 'ArrowRight') {
                e.preventDefault();
                moveDirection = 1;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft' && moveDirection === -1) {
                moveDirection = 0;
            } else if (e.code === 'ArrowRight' && moveDirection === 1) {
                moveDirection = 0;
            }
        });

        leftButton.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!isGameOver) moveDirection = -1;
        });
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!isGameOver) moveDirection = -1;
        });
        leftButton.addEventListener('mouseup', () => {
            moveDirection = 0;
        });
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            moveDirection = 0;
        });
        leftButton.addEventListener('mouseleave', () => {
            moveDirection = 0;
        });

        rightButton.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!isGameOver) moveDirection = 1;
        });
        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!isGameOver) moveDirection = 1;
        });
        rightButton.addEventListener('mouseup', () => {
            moveDirection = 0;
        });
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            moveDirection = 0;
        });
        rightButton.addEventListener('mouseleave', () => {
            moveDirection = 0;
        });

        jumpButton.addEventListener('click', (e) => {
            e.preventDefault();
            jump();
        });

        let touchStartX = 0;
        let lastTouchMove = 0;
        let hasSwiped = false;
        const touchMoveThrottle = 100;
        gameArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            hasSwiped = false;
        });

        gameArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length > 1) return;
            if (performance.now() - lastTouchMove < touchMoveThrottle) return;
            lastTouchMove = performance.now();
            let touchEndX = e.touches[0].clientX;
            const swipeThreshold = 50 / window.devicePixelRatio;
            if (Math.abs(touchEndX - touchStartX) > swipeThreshold) {
                hasSwiped = true;
                moveDirection = touchEndX > touchStartX ? 1 : -1;
            }
        });

        gameArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            moveDirection = 0;
            if (!hasSwiped) jump();
            hasSwiped = false;
        });

        character.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isMobile) jump();
        });

        restartButton.addEventListener('click', () => {
            restartGame();
        });

        gameOverDisplay.addEventListener('click', () => {
            restartGame();
        });

        gameOverDisplay.addEventListener('keydown', (e) => {
            if (e.code === 'Enter') {
                restartGame();
            }
        });

        function restartGame() {
            isGameOver = false;
            score = 0;
            life = currentConfig.maxLife;
            level = 1;
            spawnInterval = currentConfig.initialSpawnInterval;
            characterX = 50;
            isFacingRight = true;
            moveDirection = 0;
            character.style.left = `${characterX}%`;
            character.style.transform = `translateX(-50%) scaleX(1) translateZ(0)`;
            scoreDisplay.textContent = `得分: ${score} | 最高分: ${highScore}`;
            lifeDisplay.textContent = `生命: ${life}`;
            if (levelDisplay) levelDisplay.textContent = `等级: ${level}`;
            gameOverDisplay.style.display = 'none';
            gameOverDisplay.innerHTML = `
                <div>游戏结束！</div>
                <div>等级: ${level}</div>
                <div>得分: ${score}</div>
                <div>最高分: ${highScore}</div>
                <div>生命: ${life}</div>
                <div>点击或按 Enter 重新开始</div>
            `;
            updateGameAreaBackground();
            coins.forEach(coin => {
                if (coin.parentNode) {
                    coin.cleanup();
                    coin.remove();
                }
            });
            coins.length = 0;
            coinCount = 0;
            const initialCoinCount = Math.floor(Math.random() * 5) + 1;
            for (let i = 0; i < initialCoinCount; i++) {
                spawnCoin();
            }
            lastSpawnTime = performance.now();
            lastCollisionCheck = performance.now();
            lastFrameTime = performance.now();
            updateCoinSpeed();
            updateGameAreaRect();
            requestAnimationFrame(gameLoop);
            bgMusic.play().catch(error => {
                console.error('背景音乐播放失败:', error);
            });
        }

        function getExplosion() {
            let explosion = explosionPool.find(e => !e.parentNode);
            if (!explosion) {
                if (explosionPool.length >= maxExplosionPoolSize) {
                    explosion = explosionPool.shift();
                    if (explosion.parentNode) explosion.remove();
                }
                explosion = document.createElement('div');
                explosion.classList.add('explosion');
                explosionPool.push(explosion);
            }
            return explosion;
        }

        function updateCoinSpeed() {
            const fallDuration = Math.max(
                currentConfig.minFallDuration,
                currentConfig.initialFallDuration - (level - 1) * currentConfig.fallDurationDecrease
            );
            coins.forEach(coin => {
                coin.style.setProperty('--fall-duration', `${fallDuration}s`);
            });
        }

        function spawnCoin() {
            if (coinCount >= currentConfig.maxCoins(level) || isGameOver) return;
            const coin = document.createElement('div');
            coin.classList.add('coin');
            const maxX = gameArea.offsetWidth - 70;
            let randomX;
            let isValidPosition;
            do {
                randomX = Math.random() * maxX;
                isValidPosition = true;
                coins.forEach(existingCoin => {
                    const existingRect = existingCoin.getBoundingClientRect();
                    if (Math.abs(randomX - (existingRect.left - gameAreaRect.left)) < 80) {
                        isValidPosition = false;
                    }
                });
            } while (!isValidPosition);
            coin.style.left = `${randomX}px`;
            coin.style.top = '-70px';
            const fallDuration = Math.max(
                currentConfig.minFallDuration,
                currentConfig.initialFallDuration - (level - 1) * currentConfig.fallDurationDecrease
            );
            coin.style.setProperty('--fall-duration', `${fallDuration}s`);
            gameArea.appendChild(coin);
            coins.push(coin);
            coinCount++;

            coin.onerror = () => {
                coin.style.backgroundImage = `url("${fallbackCoinImage}")`;
                console.warn('Coin image failed to load, using fallback.');
            };

            const handleAnimationEnd = (e) => {
                if (e.animationName === 'fall' && coin.parentNode) {
                    coin.cleanup();
                    coin.remove();
                    coins.splice(coins.indexOf(coin), 1);
                    coinCount--;
                    life--;
                    lifeDisplay.textContent = `生命: ${life}`;
                    updateGameAreaBackground();
                    if (life <= 0) gameOver();
                }
            };

            const handleClick = (e) => {
                e.stopPropagation();
                if (!isGameOver) collectCoin(coin);
            };

            coin.addEventListener('animationend', handleAnimationEnd);
            coin.addEventListener('click', handleClick);
            coin.cleanup = () => {
                coin.removeEventListener('animationend', handleAnimationEnd);
                coin.removeEventListener('click', handleClick);
                coin.onerror = null;
            };
        }

        let lastBackgroundUpdateLife = life;
        function updateGameAreaBackground() {
            if (lastBackgroundUpdateLife === life) return;
            lastBackgroundUpdateLife = life;
            const redIntensity = (currentConfig.maxLife - life) / currentConfig.maxLife;
            gameArea.style.background = `linear-gradient(to bottom, rgba(255, 102, 102, ${redIntensity * 0.7}), rgba(255, 255, 255, 0.1)), url("https://i.ibb.co/PZbrMCsh/IMG-5097.png") no-repeat center center`;
            gameArea.style.backgroundSize = 'cover';
        }

        function collectCoin(coin) {
            score += 10;
            const newLevel = Math.floor(score / 100) + 1;
            if (newLevel > level) {
                level = newLevel;
                if (levelDisplay) levelDisplay.textContent = `等级: ${level}`;
                updateCoinSpeed();
            }
            highScore = Math.max(highScore, score);
            localStorage.setItem('highScore', highScore);
            scoreDisplay.textContent = `得分: ${score} | 最高分: ${highScore}`;
            spawnInterval = Math.max(currentConfig.minSpawnInterval, spawnInterval - currentConfig.spawnIntervalDecrease);

            const rect = coin.getBoundingClientRect();
            const explosion = getExplosion();
            explosion.style.left = `${rect.left - gameAreaRect.left + rect.width / 2 - 40}px`;
            explosion.style.top = `${rect.top - gameAreaRect.top + rect.height / 2 - 40}px`;
            gameArea.appendChild(explosion);

            character.classList.add('glow');
            setTimeout(() => {
                explosion.remove();
                character.classList.remove('glow');
            }, 600);

            if (coin.parentNode) {
                coin.cleanup();
                coin.remove();
                coins.splice(coins.indexOf(coin), 1);
                coinCount--;
            }
        }

        function checkCollisions() {
            if (isGameOver) return;
            const characterRect = character.getBoundingClientRect();
            const hitboxPaddingX = characterRect.width * 0.1;
            const hitboxPaddingY = characterRect.height * 0.1;
            const adjustedCharacterRect = {
                left: characterRect.left + hitboxPaddingX,
                right: characterRect.right - hitboxPaddingX,
                top: characterRect.top + hitboxPaddingY,
                bottom: characterRect.bottom - hitboxPaddingY,
            };
            const coinsToRemove = [];
            coins.forEach((coin) => {
                if (!coin.parentNode) return;
                const coinRect = coin.getBoundingClientRect();
                if (
                    adjustedCharacterRect.left < coinRect.right &&
                    adjustedCharacterRect.right > coinRect.left &&
                    adjustedCharacterRect.top < coinRect.bottom &&
                    adjustedCharacterRect.bottom > coinRect.top
                ) {
                    coinsToRemove.push(coin);
                }
            });
            coinsToRemove.forEach(coin => collectCoin(coin));
        }

        function gameOver() {
            isGameOver = true;
            gameOverDisplay.innerHTML = `
                <div>游戏结束！</div>
                <div>等级: ${level}</div>
                <div>得分: ${score}</div>
                <div>最高分: ${highScore}</div>
                <div>生命: ${life}</div>
                <div>点击或按 Enter 重新开始</div>
            `;
            gameOverDisplay.style.display = 'flex';
            coins.forEach(coin => {
                if (coin.parentNode) {
                    coin.cleanup();
                    coin.remove();
                }
            });
            coins.length = 0;
            coinCount = 0;
            bgMusic.pause();
        }

        function gameLoop(timestamp) {
            if (!isGameOver && timestamp - lastFrameTime >= 16) {
                try {
                    const start = performance.now();
                    updateCharacterPosition();
                    if (timestamp - lastCollisionCheck >= collisionCheckInterval) {
                        checkCollisions();
                        lastCollisionCheck = timestamp;
                    }
                    if (timestamp - lastSpawnTime >= spawnInterval && coinCount < currentConfig.maxCoins(level)) {
                        spawnCoin();
                        lastSpawnTime = timestamp;
                    }
                    lastFrameTime = timestamp;
                    const duration = performance.now() - start;
                    if (duration > 16) console.warn(`Slow frame: ${duration.toFixed(2)}ms`);
                } catch (error) {
                    console.error('游戏循环错误:', error);
                    gameOver();
                }
            }
            if (!isGameOver) requestAnimationFrame(gameLoop);
        }

        character.onerror = () => {
            character.style.backgroundImage = `url("${fallbackCharacterImage}")`;
            console.warn('Character image failed to load, using fallback.');
        };

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                isGameOver = true;
                bgMusic.pause();
            } else if (!gameOverDisplay.style.display && gameArea.style.display === 'block') {
                isGameOver = false;
                lastSpawnTime = performance.now();
                lastCollisionCheck = performance.now();
                lastFrameTime = performance.now();
                updateGameAreaRect();
                updateCoinSpeed();
                requestAnimationFrame(gameLoop);
                bgMusic.play().catch(error => {
                    console.error('背景音乐播放失败:', error);
                });
            }
        });

        // Initialize game state
        scoreDisplay.textContent = `得分: ${score} | 最高分: ${highScore}`;
        lifeDisplay.textContent = `生命: ${life}`;
        if (levelDisplay) {
            levelDisplay.textContent = `等级: ${level}`;
        } else {
            console.error('levelDisplay is null; check if #level element exists in the DOM');
        }
    </script>
</body>
</html>
